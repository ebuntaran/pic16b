[
  {
    "objectID": "posts/homework-1/index.html",
    "href": "posts/homework-1/index.html",
    "title": "Analysis of Temperature Data for Countries",
    "section": "",
    "text": "#Included to make the plots interactive\nimport plotly.io as pio\npio.renderers.default=\"iframe\"\n\n\nSetting Up the Database\nMost of this code is taken from the lecture “Working with Datasets”:\nWe first clean up the dataframes, then add them as databases using sqlite3.\n\nwith open(\"database_setup.py\", 'r') as f:\n    print(f.read())\n\nimport sqlite3\nimport pandas as pd\n\n#Mostly taken from the lecture \"Working with Datasets\"\ndef prepare_df(df):\n    df = df.set_index(keys=[\"ID\", \"Year\"])\n    df = df.stack()\n    df = df.reset_index()\n    df = df.rename(columns = {\"level_2\"  : \"Month\" , 0 : \"Temp\"})\n    df[\"Month\"] = df[\"Month\"].str[5:].astype(int)\n    df[\"Temp\"]  = df[\"Temp\"] / 100\n    return(df)\n\nwith sqlite3.connect(\"temps.db\") as conn: # create a database in current directory called temps.db\n    temps_iter = pd.read_csv(\"temps.csv\", chunksize = 100000)\n    for i, df in enumerate(temps_iter):\n        df = prepare_df(df)\n        df.to_sql(\"temperatures\", conn, if_exists = \"replace\" if i == 0 else \"append\", index = False)\n    url = \"station-metadata.csv\"\n    stations = pd.read_csv(url)\n    stations.to_sql(\"stations\", conn, if_exists = \"replace\", index=False)\n    countries = pd.read_csv(\"https://raw.githubusercontent.com/mysociety/gaze/master/data/fips-10-4-to-iso-country-codes.csv\")\n    countries.to_sql(\"countries\", conn, if_exists = \"replace\", index=False)\n\n\n\n\nQuerying the Database\nThe vast majority of the query_climate_database function is a single SQL query. We select the relevant columns and only take rows satisfying the given constraints. Since country and station data is not in the temperatures database, we need to do some merges in order to get all the relevant information into one table.\n\nimport inspect\nfrom climate_database import query_climate_database\nprint(inspect.getsource(query_climate_database))\n\ndef query_climate_database(db_file, country, year_begin, year_end, month):\n    \"\"\"\n    Query a climate database for temperature information\n\n    Args:\n        db_file: sqlite3 database file\n        country (str): Country to take temperature data\n        year_begin (int): Year to begin taking data\n        year_end (int): Year to stop taking data\n        month (int): Month to take temperature data\n    \n    Returns:\n        df: Dataframe of temperature data at the provided country in the provided time range\n    \"\"\"\n\n    cmd = \\\n    f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, C.Name, T.year, T.month, T.temp \n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    INNER JOIN countries C ON SUBSTR(S.id,1,2) = C.\"FIPS 10-4\"\n    WHERE C.Name = \"{country}\" AND T.month = {month} AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end}\n    \"\"\"\n    with sqlite3.connect(db_file) as conn:\n        df = pd.read_sql_query(cmd, conn)\n        df.rename(columns={\"Name\": \"Country\"},inplace=True)\n    return df\n\n\n\n\n\nPlotting the Data\nIn order to first filter out stations that do not have enough observation data, we add a column showing the number of years each sation has been providing data for using transform, which we can then use to filter out those rows.\nWith transform, we can estimate the yearly temperature increase using linear regression. Finally, we use plotly’s scatter_mapbox function to make a plot of the data.\n\nimport plotly\nfrom plotly import express as px\nimport numpy as np\nimport calendar\nfrom sklearn.linear_model import LinearRegression\n\ndef temperature_coefficient_plot(db_file, country, year_begin, year_end, month, min_obs, **kwargs):\n    \"\"\"\n    Use a climate database to make a geographic scatterplot\n\n    Args:\n        db_file: sqlite3 database file\n        country (str): Country to take temperature data\n        year_begin (int): Year to begin taking data\n        year_end (int): Year to stop taking data\n        month (int): Month to take temperature data\n        min_obs (int): Minimum number of years with recordings for stations\n        **kwargs: Additional arguments to be passed into scatter_mapbox \n    Returns:\n        fig: Geographic scatterplot of data\n    \"\"\"\n\n    #collect data\n    df = query_climate_database(db_file, country, year_begin, year_end, month)\n    \n    # we don't need the month and country columns anymore since month and country are arguments of the function\n    df = df.drop([\"Month\",\"Country\"], axis=1)\n\n    # filter out stations with range of years of operation less than min_obs\n    df[\"obs\"] = df.groupby([\"NAME\", \"LATITUDE\", \"LONGITUDE\"])[\"Year\"].transform(np.ptp)\n    df = df[df[\"obs\"]&gt;min_obs]\n\n    # defined in the lecture \"Advanced Data Manipulation II\": uses linear regression to calculate the estimated yearly increase\n    def coef(data_group):\n        x = data_group[[\"Year\"]] # 2 brackets because X should be a df\n        y = data_group[\"Temp\"]   # 1 bracket because y should be a series\n        LR = LinearRegression()\n        LR.fit(x, y)\n        return LR.coef_[0]\n\n    # add a column for the yearly increase\n    df = df.groupby([\"NAME\", \"LATITUDE\", \"LONGITUDE\"]).apply(coef)\n    df = df.reset_index()\n    df[0] = df[0].round(4)\n    df.rename(columns={0: \"Estimated Yearly Increase (°C)\"},inplace=True)\n\n    # create the plot with all the gathered information\n    fig = px.scatter_mapbox(df, \n                            title = f\"Estimates of yearly increase in temperature in {calendar.month_name[month]}&lt;br&gt;for stations in {country}, years {year_begin} - {year_end}\",\n                            hover_name = \"NAME\",\n                            lat = \"LATITUDE\",\n                            lon = \"LONGITUDE\", \n                            color = \"Estimated Yearly Increase (°C)\",\n                            **kwargs)\n    fig.update_coloraxes(cmid=0)\n    return fig\n\nWe can now call the functions with various arguments to see what the yearly increases in temperature are across each country.\n\ncolor_map = px.colors.diverging.RdGy_r\n\nfig1 = temperature_coefficient_plot(\"temps.db\", \"India\", 1980, 2020, 1, \n                                   min_obs = 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\n\nfig1.show()\n\n\n\n\n\nfig2 = temperature_coefficient_plot(\"temps.db\", \"France\", 1980, 2020, 1, \n                                   min_obs = 10,\n                                   zoom = 2,\n                                   mapbox_style=\"carto-positron\",\n                                   color_continuous_scale=color_map)\n\nfig2.show()\n\n\n\n\n\n\nPlotting Variation in Yearly Increase\nWe can see by the color scale that there can be significant variation of yearly increase within a country, but exactly how much is there? We can use the same data to make a box plot of yearly increases throughout a country, again using plotly.\n\ndef temperature_box_plot(db_file, country, year_begin, year_end, month, min_obs):\n    \"\"\"\n    Use a climate database to make a box plot\n\n    Args:\n        db_file: sqlite3 database file\n        country (str): Country to take temperature data\n        year_begin (int): Year to begin taking data\n        year_end (int): Year to stop taking data\n        month (int): Month to take temperature data\n        min_obs (int): Minimum number of years with recordings for stations\n    Returns:\n        fig: Box plot of data\n    \"\"\"\n    \n    #collect data\n    df = query_climate_database(db_file, country, year_begin, year_end, month)\n    \n    # we don't need the month and country columns anymore since month and country are arguments of the function\n    df = df.drop([\"Month\",\"Country\"], axis=1)\n\n    # filter out stations with range of years of operation less than min_obs\n    df[\"obs\"] = df.groupby([\"NAME\", \"LATITUDE\", \"LONGITUDE\"])[\"Year\"].transform(np.ptp)\n    df = df[df[\"obs\"]&gt;min_obs]\n\n    # defined in the lecture \"Advanced Data Manipulation II\": uses linear regression to calculate the estimated yearly increase\n    def coef(data_group):\n        x = data_group[[\"Year\"]] # 2 brackets because X should be a df\n        y = data_group[\"Temp\"]   # 1 bracket because y should be a series\n        LR = LinearRegression()\n        LR.fit(x, y)\n        return LR.coef_[0]\n\n    # add a column for the yearly increase\n    df = df.groupby([\"NAME\", \"LATITUDE\", \"LONGITUDE\"]).apply(coef)\n    df = df.reset_index()\n    df[0] = df[0].round(4)\n    df.rename(columns={0: \"Estimated Yearly Increase (°C)\"},inplace=True)\n\n    # create the plot with all the gathered information\n    fig = px.box(df, \"Estimated Yearly Increase (°C)\",\n                 title=f\"Variation in yearly increase in temperature in {calendar.month_name[month]}&lt;br&gt;for stations in {country}, years {year_begin} - {year_end}\",)\n    return fig\n\n\nfig3 = temperature_box_plot(\"temps.db\", \"India\", 1980, 2020, 1, min_obs = 10)\nfig3.show()\n\n\n\n\n\n\nIs Yearly Increase Correlated With Latitude?\nWe’ve seen that yearly increase can vary significantly within a country, so could this be tied to the latitude of the stations?\nTo answer this question, we first need another SQL querying function.\nquery_climate_database_long accesses the same information as query_climate_database, but it instead takes stations that are within tol degrees of a given longitude (long).\n\nfrom climate_database import query_climate_database_long\nimport inspect\nprint(inspect.getsource(query_climate_database_long))\n\ndef query_climate_database_long(db_file, long, tol, year_begin, year_end, month):\n    \"\"\"\n    Query a climate database for temperature information\n\n    Args:\n        db_file: sqlite3 database file\n        long (int): Longitude to take data from\n        tol (int): Tolerance for longitude value\n        year_begin (int): Year to begin taking data\n        year_end (int): Year to stop taking data\n        month (int): Month to take temperature data\n    \n    Returns:\n        df: Dataframe of temperature data near the provided longitude in the provided time range\n    \"\"\"\n\n    cmd = \\\n    f\"\"\"\n    SELECT S.name, S.latitude, S.longitude, T.year, T.month, T.temp \n    FROM temperatures T\n    LEFT JOIN stations S ON T.id = S.id\n    WHERE T.month = {month} AND T.year &gt;= {year_begin} AND T.year &lt;= {year_end} AND S.longitude &lt; {long+tol} AND S.longitude &gt; {long-tol}\n    \"\"\"\n    with sqlite3.connect(db_file) as conn:\n        df = pd.read_sql_query(cmd, conn)\n    return df\n\n\n\nWe can now use this function to gather data and plot it, again using plotly.\n\ndef temperature_longitude_plot(db_file, long, tol, year_begin, year_end, month, min_obs, **kwargs):\n    \"\"\"\n    Use a climate database to make a geographic scatterplot\n\n    Args:\n        db_file: sqlite3 database file\n        long (int): Longitude to take data from\n        tol (int): Tolerance for longitude value\n        year_begin (int): Year to begin taking data\n        year_end (int): Year to stop taking data\n        month (int): Month to take temperature data\n        min_obs (int): Minimum number of years with recordings for stations\n        **kwargs: Additional arguments to be passed into scatter \n    Returns:\n        fig: Scatterplot of data\n    \"\"\"\n    \n    #collect data\n    df = query_climate_database_long(db_file, long, tol, year_begin, year_end, month)\n    \n    # we don't need the month column anymore since month is an argument of the function\n    df = df.drop([\"Month\"], axis=1)\n\n    # filter out stations with range of years of operation less than min_obs\n    df[\"obs\"] = df.groupby([\"NAME\", \"LATITUDE\", \"LONGITUDE\"])[\"Year\"].transform(np.ptp)\n    df = df[df[\"obs\"]&gt;min_obs]\n\n    # defined in the lecture \"Advanced Data Manipulation II\": uses linear regression to calculate the estimated yearly increase\n    def coef(data_group):\n        x = data_group[[\"Year\"]] # 2 brackets because X should be a df\n        y = data_group[\"Temp\"]   # 1 bracket because y should be a series\n        LR = LinearRegression()\n        LR.fit(x, y)\n        return LR.coef_[0]\n\n    # add a column for the yearly increase\n    df = df.groupby([\"NAME\", \"LATITUDE\", \"LONGITUDE\"]).apply(coef)\n    df = df.reset_index()\n    df[0] = df[0].round(4)\n    df.rename(columns={0: \"Estimated Yearly Increase (°C)\", \"LATITUDE\": \"Latitude (°)\"},inplace=True)\n    \n    # create the plot with all the gathered information\n    fig = px.scatter(df, \n                    title = f\"Estimates of yearly increase in temperature in {calendar.month_name[month]}&lt;br&gt;for longitudes {long-tol}° to {long+tol}°, years {year_begin} - {year_end}\",\n                    hover_name = \"NAME\",\n                    x = \"Latitude (°)\",\n                    y = \"Estimated Yearly Increase (°C)\",\n                    **kwargs)\n    return fig\n\n\nfig4 = temperature_longitude_plot(\"temps.db\", 0, 5, 1980, 2020, 1, \n                                   min_obs = 10)\nfig4.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PIC 16B Blog",
    "section": "",
    "text": "Analysis of Temperature Data for Countries\n\n\n\n\n\n\n\n\n\n\n\nJan 27, 2024\n\n\nEthan Buntaran\n\n\n\n\n\n\n\n\n\n\n\n\nHomework 0\n\n\n\n\n\n\n\n\n\n\n\nJan 20, 2024\n\n\nEthan Buntaran\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/homework-0/index.html",
    "href": "posts/homework-0/index.html",
    "title": "Homework 0",
    "section": "",
    "text": "In this blog post, I will be describing how to make a simple line plot of the Palmer Penguins dataset.\n\nImporting packages and getting data\nTo start, we first import pandas in order to download and read the dataset.\n\nimport pandas as pd\nurl = \"https://raw.githubusercontent.com/pic16b-ucla/24W/main/datasets/palmer_penguins.csv\"\npenguins = pd.read_csv(url)\n\nTo help with plotting, we import matplotlib and seaborn (a library for matplotlib).\n\nimport seaborn as sns \nfrom matplotlib import pyplot as plt\nimport numpy as np\n\n\n\nSelecting Data\nWe select only the subset of data that pertains to Adelie penguins.\n\nadelie = penguins[penguins[\"Species\"] == \"Adelie Penguin (Pygoscelis adeliae)\"]\n\n\n\nPlotting Data\nFinally, we can plot the data using seaborn’s lineplot function by specifying the dataset and the axes we wish to plot against.\n\nsns.lineplot(data = adelie, x = \"Flipper Length (mm)\", y = \"Body Mass (g)\").set(title=\"Flipper Length (mm) vs Body Mass (g) for Adelie Penguins\")"
  }
]